/// <reference path="../../index.d.ts" />

/**
 * ### 👜 コンテナオブジェクト
 *
 * LLSEでは、「コンテナオブジェクト」を使用して、スロットを持ち、アイテムを保管および配置できるコンテナに関連する情報を操作します。
 *
 * ここでの **コンテナ** は広義の概念であり、伝統的なコンテナ（箱、バケツなど）だけでなく、プレイヤーのアイテムスロット、ラマが持つコンテナなども「コンテナ」として扱います。\
 * コンテナに対応するAPIを取得および使用できます。
 *
 * **注意**: プレイヤーのアイテムスロットを変更した後、プレイヤーオブジェクトのメソッド{@linkcode Player.refreshItems()}を使用して、クライアントで表示されるプレイヤーのアイテムスロットを更新することを忘れないでください。
 *
 * **注意**: コンテナオブジェクトを長期間保存しないでください。\
 * コンテナオブジェクトに対応する実体またはブロックが破壊されると、対応するコンテナオブジェクトが無効になります。\
 * したがって、特定のコンテナを長期間操作する必要がある場合は、前述の方法でリアルタイムのコンテナオブジェクトを取得してください。
 *
 * このクラスには**コンストラクタが存在しません**。イベントまたはAPIを使用して取得してください。
 *
 * @see [👜 コンテナオブジェクト API](https://docs.litebds.com/zh-Hans/#/LLSEPluginDevelopment/GameAPI/Container)
 */
declare class Container {
  /** コンテナが持つスロットの合計数 */
  readonly size: number;

  /** コンテナのタイプ名 */
  readonly type: string;

  /**
   * ### アイテムをコンテナに追加
   *
   * **注意**: プレイヤーのアイテムスロットを変更した後、プレイヤーオブジェクトのメソッド{@linkcode Player.refreshItems()}を使用して、クライアントで表示されるプレイヤーのアイテムスロットを更新することを忘れないでください。
   *
   * @param item 追加するアイテムオブジェクト
   *
   * @returns 追加に成功したかどうか
   */
  addItem(item: Item): boolean;

  /**
   * ### アイテムをコンテナの最初の空きスロットに追加
   *
   * **注意**: この関数はコンテナ内の既存のアイテムスタックにはスタックされません。
   *
   * **注意**: プレイヤーのアイテムスロットを変更した後、プレイヤーオブジェクトのメソッド{@linkcode Player.refreshItems()}を使用して、クライアントで表示されるプレイヤーのアイテムスロットを更新することを忘れないでください。
   *
   * @param item 追加するアイテムオブジェクト
   *
   * @returns 追加に成功したかどうか
   */
  addItemToFirstEmptySlot(item: Item): boolean;

  /**
   * ### コンテナに（アイテムを）追加するスペースがあるか確認
   *
   * @param item 追加するアイテムオブジェクト
   *
   * @returns 追加できるかどうか
   */
  hasRoomFor(item: Item): boolean;

  /**
   * ### コンテナ内の特定のアイテムオブジェクトを削減
   *
   * @param index 減算するアイテムが存在するスロット番号
   * @param count 減算する数量。この数がスロット内のアイテム数以上の場合、アイテムスタック全体が削除されます。
   *
   * @returns 減算に成功したかどうか
   */
  removeItem(index: number, count: number): boolean;

  /**
   * ### コンテナの特定のスロットのアイテムオブジェクトを取得
   *
   * ここで取得したアイテムオブジェクトは参照として取得されます。つまり、このアイテムオブジェクトを変更するか、そのAPIを使用すると、対応するコンテナ内のアイテムを直接操作することになります。
   *
   * **注意**: プレイヤーのアイテムスロットを変更した後、プレイヤーオブジェクトのメソッド{@linkcode Player.refreshItems()}を使用して、クライアントで表示されるプレイヤーのアイテムスロットを更新することを忘れないでください。
   *
   * @param index 取得するスロットの番号
   *
   * @returns スロット位置のアイテムオブジェクト
   */
  getItem(index: number): Item;

  /**
   * ### コンテナの特定のスロットにアイテムオブジェクトを設定
   *
   * **注意**: プレイヤーのアイテムスロットを変更した後、プレイヤーオブジェクトのメソッド{@linkcode Player.refreshItems()}を使用して、クライアントで表示されるプレイヤーのアイテムスロットを更新することを忘れないでください。
   *
   * @param index 設定するスロットの番号
   * @param item 設定するアイテムオブジェクト
   *
   * @returns 設定に成功したかどうか
   */
  setItem(index: number, item: Item): boolean;

  /**
   * ### コンテナ内のすべてのスロットのアイテムオブジェクトのリストを取得
   *
   * ここで取得したアイテムオブジェクトはすべて参照です。つまり、このアイテムオブジェクトを変更するか、そのAPIを使用すると、対応するコンテナ内のアイテムを直接操作することになります。
   *
   * **注意**: プレイヤーのアイテムスロットを変更した後、プレイヤーオブジェクトのメソッド{@linkcode Player.refreshItems()}を使用して、クライアントで表示されるプレイヤーのアイテムスロットを更新することを忘れないでください。
   *
   * @returns コンテナ内のすべてのアイテムオブジェクト
   */
  getAllItems(): Array<Item>;

  /**
   * ### コンテナをクリア
   *
   * **注意**: プレイヤーのアイテムスロットを変更した後、プレイヤーオブジェクトのメソッド{@linkcode Player.refreshItems()}を使用して、クライアントで表示されるプレイヤーのアイテムスロットを更新することを忘れないでください。
   *
   * @returns クリアに成功したかどうか
   */
  removeAllItems(): boolean;

  /**
   * ### コンテナが空かどうかを判断
   *
   * @returns コンテナが空かどうか
   */
  isEmpty(): boolean;

  /**
   * @deprecated
   * @alias {@linkcode getItem()}
   */
  getSlot(index: number): Item;

  /**
   * @deprecated
   * @alias {@linkcode getAllItems()}
   */
  getAllSlots(): Array<Item>;

  asPointer(): NativePointer;
}

declare class LLSE_Container extends Container {}
